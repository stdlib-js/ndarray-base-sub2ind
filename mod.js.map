{"version":3,"file":"mod.js","sources":["../node_modules/@stdlib/error-tools-fmtprodmsg/lib/main.js","../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2022 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Formats an error message for production.\n*\n* @param {string} code - error code\n* @param {*} ...args - error message arguments\n* @returns {string} formatted error message\n*\n* @example\n* var msg = fmtprodmsg( '3', 'wrong_type' );\n* // returns 'https://stdlib.io/e/3?&arg[]=wrong_type'\n*/\nfunction fmtprodmsg() {\n\tvar a = arguments;\n\tvar c = a[ 0 ];\n\tvar u = 'https://stdlib.io/e/'+c+'?';\n\tvar i;\n\tfor ( i = 1; i < a.length; i++ ) {\n\t\tu += '&arg[]=' + encodeURIComponent( a[ i ] );\n\t}\n\treturn u;\n}\n\n\n// EXPORTS //\n\nexport default fmtprodmsg;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// MAIN //\n\n/**\n* Converts subscripts to a linear index.\n*\n* ## Notes\n*\n* -   The function accepts the following \"modes\":\n*\n*     -   **throw**: throw an error when a subscript exceeds array dimensions.\n*     -   **normalize**: normalize negative subscripts and throw an error when a subscript exceeds array dimensions.\n*     -   **wrap**: wrap around subscripts exceeding array dimensions using modulo arithmetic.\n*     -   **clamp**: set subscripts exceeding array dimensions to either `0` (minimum index) or the maximum index along a particular dimension.\n*\n* -   When provided fewer modes than dimensions, the function recycles modes using modulo arithmetic.\n*\n* -   When provided a stride array containing negative strides, if an `offset` is greater than `0`, the function treats subscripts as mapping to a linear index in an underlying data buffer for the array, thus returning a linear index from the perspective of that buffer. If an `offset` is equal to `0`, the function treats subscripts as mapping to a linear index in an array view, thus returning a linear index from the perspective of that view.\n*\n*     ```text\n*     Dims: 2x2\n*     Buffer: [ 1, 2, 3, 4 ]\n*\n*     View = [ a00, a01,\n*              a10, a11 ]\n*\n*     Strides: 2,1\n*     Offset: 0\n*\n*     View = [ 1, 2,\n*              3, 4 ]\n*\n*     Strides: 2,-1\n*     Offset: 1\n*\n*     View = [ 2, 1,\n*              4, 3 ]\n*\n*     Strides: -2,1\n*     Offset: 2\n*\n*     View = [ 3, 4,\n*              1, 2 ]\n*\n*     Strides: -2,-1\n*     Offset: 3\n*\n*     View = [ 4, 3,\n*              2, 1 ]\n*     ```\n*\n*     ```javascript\n*     var shape = [ 2, 2 ];\n*     var strides = [ -2, 1 ];\n*     var offset = 2;\n*     var mode = [ 'throw' ];\n*\n*     // From the perspective of a view...\n*     var idx = sub2ind( shape, strides, 0, 0, 0, mode );\n*     // returns 0\n*\n*     idx = sub2ind( shape, strides, 0, 0, 1, mode );\n*     // returns 1\n*\n*     idx = sub2ind( shape, strides, 0, 1, 0, mode );\n*     // returns 2\n*\n*     idx = sub2ind( shape, strides, 0, 1, 1, mode );\n*     // returns 3\n*\n*     // From the perspective of an underlying buffer...\n*     idx = sub2ind( shape, strides, offset, 0, 0, mode );\n*     // returns 2\n*\n*     idx = sub2ind( shape, strides, offset, 0, 1, mode );\n*     // returns 3\n*\n*     idx = sub2ind( shape, strides, offset, 1, 0, mode );\n*     // returns 0\n*\n*     idx = sub2ind( shape, strides, offset, 1, 1, mode );\n*     // returns 1\n*     ```\n*\n*     In short, from the perspective of a view, view data is always ordered.\n*\n* @param {NonNegativeIntegerArray} shape - array shape\n* @param {IntegerArray} strides - stride array\n* @param {NonNegativeInteger} offset - location of the first indexed value **based** on the stride array\n* @param {...integer} i - subscripts\n* @param {StringArray} mode - specifies how to handle subscripts which exceed array dimensions\n* @throws {RangeError} must provide subscripts which do not exceed array dimensions\n* @returns {NonNegativeInteger} linear index\n*\n* @example\n* var shape = [ 3, 3, 3 ];\n* var strides = [ 9, 3, 1 ];\n* var offset = 0;\n* var mode = [ 'throw' ]\n*\n* var idx = sub2ind( shape, strides, offset, 1, 2, 2, mode );\n* // returns [ 'throw' ]\n*/\nfunction sub2ind() {\n\tvar strides;\n\tvar offset;\n\tvar nmodes;\n\tvar shape;\n\tvar ndims;\n\tvar modes;\n\tvar mode;\n\tvar idx;\n\tvar m;\n\tvar s;\n\tvar j;\n\tvar i;\n\n\tshape = arguments[ 0 ];\n\tstrides = arguments[ 1 ];\n\toffset = arguments[ 2 ];\n\tndims = shape.length;\n\tmodes = arguments[ 3+ndims ]; // last argument\n\tnmodes = modes.length;\n\tidx = offset;\n\tfor ( i = 0; i < ndims; i++ ) {\n\t\tm = shape[ i ];\n\t\tj = arguments[ i+3 ];\n\t\tmode = modes[ i%nmodes ];\n\t\tif ( mode === 'clamp' ) {\n\t\t\tif ( j < 0 ) {\n\t\t\t\tj = 0;\n\t\t\t} else if ( j >= m ) {\n\t\t\t\tj = m - 1;\n\t\t\t}\n\t\t} else if ( mode === 'wrap' ) {\n\t\t\tif ( j < 0 ) {\n\t\t\t\tj += m; // slight optimization to avoid modulo arithmetic when |j| <= m\n\t\t\t\tif ( j < 0 ) {\n\t\t\t\t\tj %= m;\n\t\t\t\t\tif ( j !== 0 ) {\n\t\t\t\t\t\tj += m;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ( j >= m ) {\n\t\t\t\tj -= m; // slight optimization to avoid modulo arithmetic when m < j <= 2m\n\t\t\t\tif ( j >= m ) {\n\t\t\t\t\tj %= m;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif ( mode === 'normalize' && j < 0 ) {\n\t\t\t\tj += m;\n\t\t\t}\n\t\t\tif ( j < 0 || j >= m ) {\n\t\t\t\tthrow new RangeError( format( '0jX5J,L4', i, j ) );\n\t\t\t}\n\t\t}\n\t\ts = strides[ i ];\n\n\t\t// Check if array view...\n\t\tif ( s < 0 && offset === 0 ) {\n\t\t\tidx -= j * s; // increments idx\n\t\t} else {\n\t\t\tidx += j * s; // may increment or decrement idx\n\t\t}\n\t}\n\treturn idx;\n}\n\n\n// EXPORTS //\n\nexport default sub2ind;\n"],"names":["fmtprodmsg","i","a","arguments","c","u","length","encodeURIComponent","sub2ind","strides","offset","nmodes","shape","ndims","modes","mode","idx","m","s","j","RangeError","format"],"mappings":";;AAiCA,SAASA,IACR,IAGIC,EAHAC,EAAIC,UACJC,EAAIF,EAAG,GACPG,EAAI,uBAAuBD,EAAE,IAEjC,IAAMH,EAAI,EAAGA,EAAIC,EAAEI,OAAQL,IAC1BI,GAAK,UAAYE,mBAAoBL,EAAGD,IAEzC,OAAOI,CACR,CCqFA,SAASG,IACR,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAlB,EASJ,IANAQ,EAAUN,UAAW,GACrBO,EAASP,UAAW,GAGpBQ,GADAG,EAAQX,UAAW,GADnBU,GAHAD,EAAQT,UAAW,IAGLG,UAECA,OACfU,EAAMN,EACAT,EAAI,EAAGA,EAAIY,EAAOZ,IAAM,CAI7B,GAHAgB,EAAIL,EAAOX,GACXkB,EAAIhB,UAAWF,EAAE,GAEH,WADdc,EAAOD,EAAOb,EAAEU,IAEVQ,EAAI,EACRA,EAAI,EACOA,GAAKF,IAChBE,EAAIF,EAAI,QAEH,GAAc,SAATF,EACNI,EAAI,GACRA,GAAKF,GACI,GAEG,KADXE,GAAKF,KAEJE,GAAKF,GAGIE,GAAKF,IAChBE,GAAKF,IACKA,IACTE,GAAKF,QAOP,GAHc,cAATF,GAAwBI,EAAI,IAChCA,GAAKF,GAEDE,EAAI,GAAKA,GAAKF,EAClB,MAAM,IAAIG,WAAYC,EAAQ,WAAYpB,EAAGkB,KAG/CD,EAAIT,EAASR,IAGJ,GAAgB,IAAXS,EACbM,GAAOG,EAAID,EAEXF,GAAOG,EAAID,CAEZ,CACD,OAAOF,CACR"}